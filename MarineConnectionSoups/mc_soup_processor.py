__author__ = 'thorsteinn'

from mc_soup import mc_soup
from db_to_file_helpers.jsonDicts_to_file import append_db_to_file
from db_format_helpers.is_number import is_number
import json
import os

def mc_soup_processor(requested_runs=40, wishlist_filename='wishlist.txt', **kwargs):
    """
    A script used for mining marine connection for available ships using imo-ids
    Prior to using this script, a file containing a list of imo-id's should be available.
    This "wishlist" can be generated by using json.dump() of a list into a file.

    Three items can be added as kwargs:
        1) a file name where collected records should be stored.
        2) a file for log entries. This file will be overwritten each time.
        3) a file name for where the id numbers completed will be stored
        4) a switch for verbose output
    :param requested_runs: how many records should be processed from the 'wishlist'. The default value is 40 (semi-fast)
    :param wishlist_filename: exact filename for the wishlist file.
    :param kwargs:  db_output_filename: the filename of the output file.
                    ids_completed_filename: The filename where the list of ids that are completed is stored.
                    log_filename: the filename of the log file
    :return:
        1) The process picks up values from the wishlist_file and collects the records from maritime connection.
        2) The process formats the records in a dictionary formats and appends it to the file specified in 'db-output'
        3) The process removes the value from the wishlist_file
        4) The process is repeated 'rec' times'%s_processed.txt' % wishlist
    """


    # Check if the wishlist points to an actual file
    if os.path.isfile(wishlist_filename) is False:
        print "%s does not exist. Make sure you have a valid file" % wishlist_filename
        return False
    else:
        # if the file exist, get the directory name
        work_directory = os.path.dirname(wishlist_filename)  # all other files should be saved in the same directory
        wishlist_file = os.path.basename(wishlist_filename)  # this is the actual file pointed to
        wishlist_n = os.path.splitext(wishlist_filename)[0]  # this is the first part of the file passed

        # get the list of id numbers that I need to work with
        with open(wishlist_filename, 'r') as f:
            imo_wish_list = json.load(f)
            if len(imo_wish_list) == 0:  # is the file empty? is the first item a number longer than 1
                print "{file} is empty, provide a file that contains a list of imo-ids".format(file=wishlist_filename)
                return False
            if is_number(imo_wish_list[0]) is False:
                print "check the format of the input file %s" % wishlist_filename
                return False

            # compare the number of runs requested and number of ids available
            if requested_runs > len(imo_wish_list):
                requested_runs = len(imo_wish_list)
            else:
                requested_runs = int(requested_runs)

        # take only the requested number of runs out of the wishlist
        part_list = imo_wish_list[:requested_runs]

    # format names for other files that need to be generated.
    if 'db_output_filename' in kwargs.keys():
        name_grab = os.path.basename(kwargs.pop('db_output_filename'))  # this returns only the file name
        db_output_filename = os.path.join(work_directory, name_grab)
    else:
        db_output_filename = '{file}_output.txt'.format(file=wishlist_n)
    # this forces the log-file to be written into the same directory as the wishlist

    # do the same setup swap for the ids
    if os.path.isfile(db_output_filename) is False:
        open(db_output_filename, 'a').close()

    if 'ids_completed_filename' in kwargs.keys():
        name_grab = os.path.basename(kwargs.pop('ids_completed_filename'))
        ids_completed_filename = os.path.join(work_directory, name_grab)
    else:
        ids_completed_filename = '{file}_completed.txt'.format(file=wishlist_n)


    if os.path.isfile(ids_completed_filename) is False:
        open(db_output_filename, 'a').close()
        ids_collected = []
    else:
        try:
            with open(ids_completed_filename, 'r') as f:
                ids_collected = json.load(f)
        except Exception, me:
            print me.message
            return False

    if 'log_filename' in kwargs.keys():
        name_grab = os.path.basename(kwargs.pop('log_filename'))  # this returns only the file name
        log_filename = os.path.join(work_directory, name_grab)
    else:
        log_filename = '%s_log.txt' % wishlist_n


    verbose = kwargs.pop('verbose', True)

    if verbose:
        print '{message: <90}'.format(message="="*90)
        print '{message: <90}'.format(message=">  From dnv_exchange_soup_new.main:")
        print '{message: <90}'.format(message=">  File setup completed:")
        print '{message: <90}'.format(message=">  Wishlist of dnv-id values found in file: %s" % wishlist_file)
        print '{message: <90}'.format(message=">     All input and output records are printed to the root: %s" % work_directory)
        print '{message: <90}'.format(message=">     A list of completed dnv-ids is found in the file: %s" % os.path.basename(log_filename))
        print '{message: <90}'.format(message=">     db records are found in the file: %s" % os.path.basename(db_output_filename))
        print '{message: <90}'.format(message="="*90)

    # setup complete. Notify the start of process
    with open(log_filename, 'a') as f:
        f.write('='*20+'\nNew run:\n' + '='*20+'\n')
        message = "Currently there are {processed} records for ships and {remaining} records left".format(
          processed=len(ids_collected),
          remaining=len(imo_wish_list)
        )
        f.write(message + '\nCurrent request:\n')
        json.dump(part_list, f)
        f.write('\n')
        if verbose:
             print message

    # HERE BE DRAGONS = here the process starts
    cycle_count = 1
    for imo_id in part_list[:]:
        with open(log_filename, 'a') as f:
            message = "{cycle} of {total} : Processing imo_id = {imo:07d}".format(
                cycle=cycle_count,
                total=requested_runs,
                imo=imo_id
            )
            f.write(message + '; ')
            if verbose:
                print message

        # create a name and an empty db for the data
        entry_name = 'imo{0:07d}'.format(imo_id)
        db = {}
        db[entry_name] = mc_soup(imo_id)            # this process gets the data from the website
        append_db_to_file(db, db_output_filename)   # this function adds the collected db to the appointed file

        ids_collected.append(imo_id)                # this adds the id number to the "collected ids list
        imo_wish_list.remove(imo_id)                # this removes the id from the wishlist list
        part_list.remove(imo_id)                    # this removes the id from the part-list (for debugging reason)

        # log the process
        with open(log_filename, 'a') as f:
            f.write(message)
            f.write('\n'+'-'*20+'\nRemaining list: \n')
            json.dump(part_list, f)
            f.write('\n')
            if verbose:
                message = "Obtained db with length = %s items" % len(db[entry_name])
                print message

        # dump the process into the correct files
        with open(ids_completed_filename, 'w') as f:
            json.dump(ids_collected, f)
        with open(wishlist_filename, 'w') as f:
            json.dump(imo_wish_list, f)

        cycle_count += 1

    print "From mc_soup_processor:\n " \
          "Process completed: \nOutput file: %s.\nLogfile: %s" % \
          (db_output_filename, db_output_filename)


mc_soup_processor(requested_runs=2000,
     wishlist_filename='./mc_get2/wishlist.txt',
     db_output_filename='mc_get_db_5.txt',
     log_filename='mc_get_db_5_log.txt')
